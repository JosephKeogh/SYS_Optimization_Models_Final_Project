#Sets
set TASKS :=
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25 ;


set DEF_STATIONS;                #(KD) The set of definite stations
set PROB_STATIONS;               #(KP) The set of probable stations
set STATIONS;                    #(K) The set of all possible stations (Union of DEF_STATIONS and PROB_STATIONS); indexed by (k)
set RELATIONS :=
(1,3)
(2,3)
(3,4)
(4,5)
(4,8)
(5,6)
(6,7)
(6,10)
(7,11)
(7,12)
(8,9)
(8,11)
(9,13)
(9,10)
(11,13)
(12,15)
(13,14)
(14,16)
(14,19)
(14,20)
(15,17)
(15,22)
(16,18)
(17,18)
(17,23)
(18,25)
(19,22)
(20,21)
(20,25)
(21,22)
(21,24)
(23,25) ;

set PREDECESSORS {TASKS};        #(P_i) The set of all direct and indirect predecessors for task i
set SUCCESSORS {TASKS};          #(F_i) The set of all direct and indirect successors for task i
set FEASIBLE_STATIONS {TASKS};   #(FS_i) The set of stations to which task i is feasibly assignable
set FEASIBLE_TASKS {STATIONS};   #(FT_k) The set of tasks that are feasibly assignable to station k

#Parameters
param num_tasks := 25;

param exec_time :=              #Execution time for each task
1	  4
2	  3
3	  9
4	  5
5	  9
6	  4
7	  8
8	  7
9	  5
10	1
11	3
12	1
13	5
14	3
15	5
16	3
17	13
18	5
19	2
20	3
21	7
22	5
23	3
24	8
25	4 ;


param min_exec_time := 1;

param max_exec_time := 13;

param sum_exec_time := 125;

param lowest_cycle_time;           #(c-underlined) The lower bound on the cycle time
param highest_cycle_time;          #(c-bar) The upper bound on the cycle time
param lowest_num_stations;         #(m-underlined) The lower bound on the number of stations
param highest_num_stations;        #(m-bar) The upper bound on the number of stations
param pred_exec_time {TASK};       #(tP_i) The total execution time for all predecessors of task i
param succ_exec_time {TASK};       #(tF_i) The total execution time for all successors of task i
param earliest_station {TASK};     #(E_i) The earliest possible station for task i
param latest_station {TASK};       #(L_i) The latest possible station for task i

#Variables
var TaskToStation {TASKS, STATIONS} binary;     #(x_ik) 1 if task i assigned to station k, 0 otherwise
var IdleTime {STATION} >= 0;                    #(delta_k) The idle time for station k
var StationUsed {STATIONS} binary;              #(u_k) 1 if any task is assigned to station k, 0 otherwise
